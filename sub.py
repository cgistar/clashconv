#!/usr/bin/env python
# -*- coding: utf-8 -*-

import base64
import collections
import logging
import os
import re
import requests
import tempfile
import json
import yaml
from flask import Flask, request
from urllib.parse import urlsplit, unquote, parse_qsl
from werkzeug.exceptions import HTTPException

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()
app = Flask(__name__)


def ordered_yaml_load(stream, Loader=yaml.SafeLoader, object_pairs_hook=collections.OrderedDict):
    class OrderedLoader(Loader):
        pass

    def _construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))

    OrderedLoader.add_constructor(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, _construct_mapping)
    return yaml.load(stream, OrderedLoader)


def ordered_yaml_dump(data, stream=None, Dumper=yaml.SafeDumper, object_pairs_hook=collections.OrderedDict, **kwds):
    class OrderedDumper(Dumper):
        pass

    def _dict_representer(dumper, data):
        return dumper.represent_mapping(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, data.items())

    OrderedDumper.add_representer(object_pairs_hook, _dict_representer)
    return yaml.dump(data, stream, OrderedDumper, **kwds)


class SubConv:
    def __init__(self, fileName=None) -> None:
        self.countrys = collections.OrderedDict()
        self.countrys["È¶ôÊ∏Ø"] = "üá≠üá∞È¶ôÊ∏Ø"
        self.countrys["Âè∞Êπæ"] = "üá®üá≥Âè∞Êπæ"
        self.countrys["Êñ∞Âä†Âù°"] = "üá∏üá¨Êñ∞Âä†Âù°"
        self.countrys["Êó•Êú¨"] = "üáØüáµÊó•Êú¨"
        self.countrys["Èü©ÂõΩ"] = "üá∞üá∑Èü©ÂõΩ"
        self.countrys["Âç∞Â∫¶"] = "üáÆüá≥Âç∞Â∫¶"
        self.countrys["ÁæéÂõΩ"] = "üá∫üá∏ÁæéÂõΩ"
        self.countrys["‰øÑÁΩóÊñØ"] = "üá∑üá∫‰øÑÁΩóÊñØ"
        self.countrys["Âæ∑ÂõΩ"] = "üá©üá™Âæ∑ÂõΩ"
        self.countrys["Êæ≥Â§ßÂà©‰∫ö"] = "üá¶üá∫Êæ≥Â§ßÂà©‰∫ö"
        self.countrys["ÈòøËÅîÈÖã"] = "üá¶üá™ÈòøËÅîÈÖã"
        self.countrys["Ê≥¢ÂÖ∞"] = "üáµüá±Ê≥¢ÂÖ∞"
        self.countrys["ÂúüËÄ≥ÂÖ∂"] = "üáπüá∑ÂúüËÄ≥ÂÖ∂"
        self.countrys["Âä†ÊãøÂ§ß"] = "üá®üá¶Âä†ÊãøÂ§ß"
        self.countrys["Ê≥ïÂõΩ"] = "üá´üá∑Ê≥ïÂõΩ"
        self.countrys["Ëã±ÂõΩ"] = "üá¨üáßËã±ÂõΩ"
        self.countrys["Ëç∑ÂÖ∞"] = "üá≥üá±Ëç∑ÂÖ∞"
        if fileName:
            f = open(fileName, "r", encoding="utf-8")
            self._stream = f.read()
            f.close()

    def _yaml_load(self):
        return ordered_yaml_load(self._stream)

    def _yaml_dump(self, data):
        return ordered_yaml_dump(data, allow_unicode=True, default_flow_style=False)

    def b64decode(self, text) -> str:
        if isinstance(text, str):
            encode_bytes = text.encode()
        elif isinstance(text, bytes):
            encode_bytes = text
        add = 4 - (len(encode_bytes) % 4)
        if add:
            encode_bytes += b"=" * add
        return base64.b64decode(encode_bytes).decode("utf-8")

    def _parse_ss(self, url):
        node = dict()
        node["name"] = unquote(url.fragment)
        node["server"] = url.hostname
        node["port"] = url.port
        node["type"] = url.scheme
        userpass = self.b64decode(url.username).split(":")
        node["cipher"] = userpass[0]
        node["password"] = userpass[1]
        return node

    def _parse_trojan(self, url):
        node = dict()
        query = dict(parse_qsl(url.query))
        node["name"] = unquote(url.fragment)
        node["server"] = url.hostname
        node["port"] = url.port
        node["type"] = "trojan"
        node["password"] = url.username
        node["udp"] = True
        if query.get("sni"):
            node["sni"] = query["sni"]
        node["skip-cert-verify"] = False
        if query.get("allowInsecure"):
            node["skip-cert-verify"] = True
        return node

    def _parse_vmess(self, url):
        node = dict()
        info = json.loads(self.b64decode(url[1]))
        node["name"] = info["ps"]
        node["server"] = info["add"]
        node["port"] = info["port"] or "443"
        node["type"] = url.scheme
        node["uuid"] = info["id"]
        node["alterId"] = info.get("aid") or "0"
        node["cipher"] = info.get("scy") or "auto"
        node["udp"] = True
        node["network"] = info["net"]
        path = info.get("path") or "/"
        if info.get("tls"):
            node["tls"] = True
        if node["network"] == "ws":
            opts = dict()
            opts["path"] = path
            opts["max-early-data"] = 2048
            opts["early-data-header-name"] = "Sec-WebSocket-Protocol"
            if info.get("host"):
                opts["headers"] = {"Host": info["host"]}
            node["ws-opts"] = opts
            node["ws-path"] = path
            if opts.get("headers"):
                node["ws-headers"] = {"Host": info["host"]}
        if node["network"] == "h2":
            opts = dict()
            opts["path"] = path
            if info.get("host"):
                opts["host"] = list(map(str.strip, info["host"].split(",")))
            node["h2-opts"] = opts
        node["port"] = int(node["port"])
        node["alterId"] = int(node["alterId"])
        return node

    def _parse_vless(self, url):
        node = dict()
        query = dict(parse_qsl(url.query))
        path = query.get("path") or "%2F"
        path = unquote(path)
        network = query.get("type") or "http"
        # { udp: true, sni: 13-251-128-188.nhost.00cdn.com, : true }
        node["name"] = unquote(url.fragment)
        node["server"] = url.hostname
        node["port"] = url.port
        node["type"] = url.scheme
        node["uuid"] = url.username
        if query.get("sni"):
            node["servername"] = query["sni"]
        security = query.get("security")
        if security == "xtls":
            node["flow"] = query.get("flow") or "xtls-rprx-direct"
        elif security == "tls":
            node["tls"] = True
            node["udp"] = True
            node["network"] = network
            if network == "ws":
                opts = dict()
                opts["path"] = path
                if query.get("host"):
                    opts["headers"] = {"Host": unquote(query["host"])}
                node["ws-opts"] = opts
            elif network == "http":
                opts = dict()
                opts["path"] = path
                if query.get("host"):
                    opts["headers"] = {"Host": unquote(query["host"])}
                node["h2-opts"] = opts
            elif network == "grpc":
                opts = dict()
                opts["grpc-service-name"] = unquote(query["host"])
                node["grpc-opts"] = opts

        return node

    def _sub_decode(self, s):
        if not s:
            return None
        o = urlsplit(s)
        t = o.scheme
        try:
            if t == "ss":
                return self._parse_ss(o)
            elif t == "trojan" or t == "trojan-go":
                return self._parse_trojan(o)
            elif t == "vmess":
                return self._parse_vmess(o)
            elif t == "vless":
                return self._parse_vless(o)
        except Exception as e:
            logger.error(e)
        return None

    def download_rules(self, urls: list):
        """
        ‰∏ãËΩΩËßÑÂàôÊñá‰ª∂
        """
        cwd = tempfile.gettempdir()     # os.getcwd()
        for url in urls:
            filename = os.path.basename(url)
            filepath = os.path.join(cwd, filename)
            if not os.path.exists(filepath):
                response = requests.get(url)
                if response.ok:
                    with open(filepath, "wb") as f:
                        f.write(response.content)

    def get_rule(self, groupname, urls: list):
        self.download_rules(urls)
        rules = []
        cwd = tempfile.gettempdir()     # os.getcwd()
        for url in urls:
            filename = os.path.basename(url)
            filepath = os.path.join(cwd, filename)

            # ‰ªé‰∏ãËΩΩÁöÑÊñá‰ª∂‰∏≠ËØªÂèñÈÖçÁΩÆÈ°π
            with open(filepath, "rt", encoding="utf-8") as f:
                lines = f.readlines()
                for line in lines:
                    if line.startswith("DOMAIN") or line.startswith("SOURCE") or line.startswith("GEOIP"):
                        rules.append(f"{line.strip()},{groupname}")
                    elif line.startswith("IP-CIDR"):
                        rule = list(map(str.strip, line.split(",")))
                        if rule[-1] == "no-resolve":
                            rules.append("{},{},{}".format(",".join(rule[:-1]), groupname, rule[-1]))
                        else:
                            rules.append(f"{line.strip()},{groupname}")
        return sorted(list(set(rules)))

    def build_rule(self):
        config = [
            [
                "üõë ÂÖ®ÁêÉÊã¶Êà™",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/BanAD.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/BanProgramAD.list",
            ],
            [
                "üéØ ÂÖ®ÁêÉÁõ¥Ëøû",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/LocalAreaNetwork.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/UnBan.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/ChinaDomain.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/ChinaMedia.list",
            ],
            [
                "üçé ËãπÊûú",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Apple.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/AppleTV.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/AppleNews.list",
            ],
            ["üé• Â•àÈ£û", "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/Netflix.list"],
            [
                "üìπ YouTube",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/YouTube.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/GoogleFCM.list",
                "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/GoogleCN.list",
            ],
            ["üéÆ Steam", "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/Steam.list"],
            ["‚ìÇÔ∏è ÂæÆËΩØ", "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Microsoft.list"],
            ["üé∂ Spotify", "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/Spotify.list"],
            ["üåç Github", "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/Ruleset/Github.list"],
            ["DIRECT", "https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/ChinaDomain.list"],
        ]
        rules = [
            "IP-CIDR,198.18.0.1/16,REJECT,no-resolve",
            "GEOIP,private,DIRECT,no-resolve",
            "RULE-SET,personal,DIRECT"
        ]
        for x in config:
            r = self.get_rule(x[0], x[1:])
            rules.extend(r)
        add_rule = [
            "RULE-SET,Custom,Ëá™ÂÆö‰πâ",
            "DOMAIN-KEYWORD,aria2,üéØ ÂÖ®ÁêÉÁõ¥Ëøû",
            "DOMAIN-KEYWORD,xunlei,üéØ ÂÖ®ÁêÉÁõ¥Ëøû",
            "DOMAIN-KEYWORD,yunpan,üéØ ÂÖ®ÁêÉÁõ¥Ëøû",
            "DOMAIN-KEYWORD,Thunder,üéØ ÂÖ®ÁêÉÁõ¥Ëøû",
            "DOMAIN-KEYWORD,XLLiveUD,üéØ ÂÖ®ÁêÉÁõ¥Ëøû",
            "GEOIP,CN,üéØ ÂÖ®ÁêÉÁõ¥Ëøû",
            "MATCH,üêü ÊºèÁΩë‰πãÈ±º",
        ]
        rules.extend(add_rule)
        return rules

    def parse_base_nodes(self, nodes):
        test_params = {"url": "http://www.gstatic.com/generate_204", "interval": 300}
        result = dict()
        result["mixed-port"] = 7890
        result["allow-lan"] = True
        result["bind-address"] = "*"
        result["mode"] = "rule"
        result["log-level"] = "info"
        result["external-controller"] = "127.0.0.1:9090"
        proxies = []
        result["proxies"] = proxies

        nodeNames = []
        for node in nodes:
            proxie = self._sub_decode(node)
            if proxie:
                proxies.append(proxie)
                nodeNames.append(proxie["name"])

        allNodes = []
        autoNodes = []
        otherNodes = []
        groups = collections.defaultdict(list)
        for item in ["ÂÄçÊâ£", "test", "ÊµãËØï"]:
            addNodes = set()
            for p in nodeNames:
                if p.find(item) >= 0:
                    addNodes.add(p)
                    groups[item].append(p)
            n = set(nodeNames) - addNodes
            nodeNames = [x for x in nodeNames if x in n]
        # Êî∂ÈõÜÂêÑÂõΩ‰∏ìÁ∫ø
        pattern = re.compile(r"0\.\d+?")
        for name, flag in self.countrys.items():
            addNodes = set()
            for p in nodeNames:
                if p.find(name) >= 0:
                    addNodes.add(p)
                    if pattern.search(p):
                        groups[f"{flag}‰ºòÊÉ†"].append(p)
                    elif p.find("‰∏ìÁ∫ø") >= 0:
                        groups[f"{flag}‰∏ìÁ∫ø"].append(p)
                    else:
                        groups[flag].append(p)
            n = set(nodeNames) - addNodes
            nodeNames = [x for x in nodeNames if x in n]

        groups["ÂÖ∂ÂÆÉ"] = list(nodeNames)
        result["proxy-groups"] = []

        proxyGroups = []
        for item in groups.keys():
            g = {}
            if item == "ÂÄçÊâ£":
                g = {"name": "Â§öÂÄçÊâ£Ë¥π", "type": "select", "proxies": sorted(groups[item])}
                otherNodes.append(g["name"])
            elif item in ("test", "ÊµãËØï"):
                g = {"name": "ÊµãËØïÁ∫øË∑Ø", "type": "select", "proxies": sorted(groups[item])}
                otherNodes.append(g["name"])
            elif item == "ÂÖ∂ÂÆÉ":
                g = {"name": item, "type": "select", "proxies": sorted(groups[item])}
            else:
                # name = f"{item}Ëá™Âä®"
                g = {"name": item, "type": "url-test", "proxies": sorted(groups[item]), **test_params}
                autoNodes.append(item)
            if g.get("proxies"):
                allNodes.extend(g["proxies"])
                proxyGroups.append(g)
        autoNodes.extend(otherNodes)
        result["rule-providers"] = {
            "Custom": {
                "type": "http",
                "behavior": "classical",
                "path": "./rule_provider/Custom",
                "url": "https://brinfo.cc/clash/rule_provider/Custom.yaml",
                "interval": 3600,
            },
            "personal": {
                "type": "http",
                "behavior": "classical",
                "path": "./rule_provider/personal",
                "url": "https://brinfo.cc/clash/rule_provider/personal.yaml",
                "interval": 3600,
            },
        }
        result["proxy-groups"] = [
            {"name": "üî∞ ËäÇÁÇπÈÄâÊã©1", "type": "select", "proxies": allNodes},
            {"name": "üî∞ ËäÇÁÇπÈÄâÊã©2", "type": "select", "proxies": allNodes},
            {"name": "‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "type": "url-test", "proxies": autoNodes, **test_params},
            {"name": "üéØ ÂÖ®ÁêÉÁõ¥Ëøû", "type": "select", "proxies": ["DIRECT"]},
            {"name": "üõë ÂÖ®ÁêÉÊã¶Êà™", "type": "select", "proxies": ["REJECT", "DIRECT"]},
            {"name": "‚ìÇÔ∏è ÂæÆËΩØ", "type": "select", "proxies": ["üéØ ÂÖ®ÁêÉÁõ¥Ëøû", "‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "üåç Github", "type": "select", "proxies": ["‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "üéÆ Steam", "type": "select", "proxies": ["üéØ ÂÖ®ÁêÉÁõ¥Ëøû", "‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "üé∂ Spotify", "type": "select", "proxies": ["‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "üçé ËãπÊûú", "type": "select", "proxies": ["üéØ ÂÖ®ÁêÉÁõ¥Ëøû", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "üé• Â•àÈ£û", "type": "select", "proxies": ["‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "üìπ YouTube", "type": "select", "proxies": ["‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "Ëá™ÂÆö‰πâ", "type": "select", "proxies": ["‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", *autoNodes]},
            {"name": "üêü ÊºèÁΩë‰πãÈ±º", "type": "select", "proxies": ["‚ôªÔ∏è Ëá™Âä®ÈÄâÊã©", "üî∞ ËäÇÁÇπÈÄâÊã©1", "üî∞ ËäÇÁÇπÈÄâÊã©2", "üéØ ÂÖ®ÁêÉÁõ¥Ëøû", *autoNodes]},
        ]
        result["proxy-groups"].extend(proxyGroups)
        result["rules"] = self.build_rule()
        return result


@app.errorhandler(Exception)
def handle_error(e):
    code = 500
    if isinstance(e, HTTPException):
        code = e.code
        logger.info(e)
    return str(e), code


@app.route("/subconv", methods=["GET"])
def get_sub():
    urls = request.args.getlist("url")
    sites = []
    subConv = SubConv()
    for url in urls:
        response = requests.get(url)
        if not response.ok:
            raise ValueError("Ëé∑ÂèñËÆ¢ÈòÖÂ§±Ë¥•")
        s = response.content.decode()
        nodes = subConv.b64decode(s).split("\n")
        sites.extend(nodes)
    content = subConv.parse_base_nodes(sites)
    # a = self._yaml_dump(result)
    result = yaml.safe_dump(content, allow_unicode=True, sort_keys=False, default_flow_style=False)
    return result


@app.route("/subconv", methods=["POST"])
def post_sub():
    subConv = SubConv()
    nodes = subConv.b64decode(request.data).split("\n")
    content = subConv.parse_base_nodes(nodes)
    # a = self._yaml_dump(result)
    result = yaml.safe_dump(content, allow_unicode=True, sort_keys=False, default_flow_style=False)
    return result


if __name__ == "__main__":
    app.run("0.0.0.0", 8080)
